### string

```c++
a.erase(int first,int last)		//删除第first到第last个
a.clear()					//删除全部字符
```

### vector

```c++
vector<int>a,b;
a.push_back(1);	// 推入一个新的值到数组最后
a.emplace_back(1);
a.pop_back();		// 删除数组最后的那个值
a.front();			// 数组开头的值
a.back();			// 数组结尾的值
vector<int>::iterator iter//定义迭代器
iter=a.begin();
iter=a.end();
```

### set

**如果需要集合中的元素允许重复那么可以使用multiset。**

由于set是红黑树，所以满足以下内容
1、内部有序(默认从小到大)
2、没有重复值，如果出现重复值会不断被覆盖
4、不可以修改节点上的值
5、修改操作只能进行插入和删除两个操作

```c++
/*set的建立*/
set<int> seta; //默认是小于比较器less<int>的set
multiset<int> mseta;
set<int, greater<int> > setb; //创建一个带大于比较器的set
s.insert()      插入一个元素 
s.erase()       删除一个元素 
s.size() 　　　　返回当前set容器中的元素个数
s.find()		查找一个元素，如果不存在，返回值为s.end()
set<int>::iterator it;
it=s.lower_bound(x)		返回第一个大于等于给定关键值的元素
it=s.upper_bound(x)  	返回第一个大于给定关键值的元素
it=--s.upper_bound(x)	返回第一个小于等于给定关键值的元素
it=--s.lower_bound(x)	返回第一个小于给定关键值的元素
set遍历
for(set<int>::iterator it=s.begin();it!=s.end();it++)
```

```c++
/*自定义set*/
struct Queue {
	int num, id;
	bool operator < (const Queue &t)const {
		if (num == t.num)	return id < t.id;
        	return	num<t.num;
	}
};
Queue q[MAXN];set<Queue>s;
int main() {
	Queue x;
	for (int i = 1;i <= 10;i++) {
		x.id = i;x.num = 10 - i;s.insert(x);
	}
	for (auto it = s.begin();it != s.end();it++) {
		cout << (*it).id << " " << (*it).num << endl;
	}
	puts("");
}
```

### pair

表示一组键对（有两个变量的结构体）

pair有两个公有属性:first,second;

```c++
//第一种方法创建一个对组
pair<string, int> pair1(string("name"), 20);
cout << pair1.first << endl; //访问pair第一个值
cout << pair1.second << endl;//访问pair第二个值
//第二种
pair<string, int> pair2 = make_pair("name", 30);
cout << pair2.first << endl;
cout << pair2.second << endl;
//pair=赋值
pair<string, int> pair3 = pair2;
cout << pair3.first << endl;
cout << pair3.second << endl;
//pair排序   默认优先first从小到大，如果first相同则second从小到大。
pair<int,string>p[100];
sort(p,p+100);
//pair与其他结构嵌套
vector<pair<int,string> >vp;
queue<pair<float,int> >qp;
queue<pair<pair<int,int>,int> >qpp;
```

### map

```c++
map<char,int>m;
直接视作一个插入，查找等代价都为log(n)的数组
m.insert(make_pair('a',1));	//加入字典
m.insert({'a',1});		   //加入字典
m['c']=1				//加入字典
m.erase('a');			   //从字典中删除
m.count('a');			   //字典中是否存在
m.find('a');		//返回对应值的迭代器（若无则返回尾后迭代器）
for(auto [x,y]:mpa){cout<<x<<" "<<y<<endl;}
for(auto &x:mpa){cout<<x.first<<" "<<x.second<<endl;}
```

### 组合操作

#### 1. map与pair组合

```
int main() {
	int m;
	cin >> m;
	for (int i = 1;i <= m;i++) {
		int x1, x2, x3;
		cin >> x1 >> x2>>x3;
		M.insert(make_pair(x1, make_pair(x2, x3)));
	}
	int tt;
	cin >> tt;
	auto it=M.find(tt);
	cout << (*it).first << " " << (*it).second.first <<" "<< (*it).second.second << endl;
}
```

#### 2. set与pair组合

```c++
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-48,ch=getchar();
    return ret*f;
}
struct node{
	int x,y;
}a[MAXN];
bool cmp(node a,node b){
	if(a.y==b.y)	return a.x<b.x;
	return a.y<b.y;
}
void solve(){
	int n,k;n=read();k=read();
	int ans=0;
	for(int i=1;i<=n;i++){
		a[i].x=read();
		a[i].y=read();
	}
	sort(a+1,a+n+1,cmp);
	set<pair<int,int> >s;
	for(int i=1;i<=n;i++){
		int L=a[i].x,R=a[i].y;
		auto it=s.lower_bound({L,-1});
		if(it==s.end()){
			ans++;
			if(k!=1)//k如果为1，那么取一次就已经达到了该删除的情况，所以不用录入。
			s.insert({R,1});
			continue;
		}
		if((*it).second+1<k)	s.insert({(*it).first,(*it).second+1});//未超过一天取出的上限，则将后缀值增大后放入。
		s.erase(it);//删除前缀小的那个值
	}
	cout<<ans<<endl;
}
int main(){
	int t;
	t=read();
	while(t--)	solve();
}
```

### 分块思想

#### 区间和1

给定一个长度为n的序列{a[i]},进行n次操作，操作分为两种

1.在a[L]~a[R]之间所有数加上x。

2.求a[L]~a[R]上所有的数和。

利用b数组记录后来每个块的变化状态

#### 思路

`预处理方法`

将序列案每s个元素进行分块，并记录每个分块的区间和

`查询操作`

1.若l和r在同一个快中，暴力求和，for(i,l~r)	sum+=a[i];

2.若不在一个块，由l开头的不完整块，中间的若干个完整块，以r结尾的不完整块之和

`修改操作`

1.同一个块内:暴力修改

2.不在同一个块内:完整块直接修改b[i],非完整块中暴力修改。

#### 代码

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int id[50005], len;
// id 表示块的编号, len=sqrt(n) , 即上述题解中的s, sqrt的时候时间复杂度最优
long long a[50005], b[50005], s[50005];
// a 数组表示数据数组, b 数组记录每个块的整体赋值情况, 类似于 lazy_tag, s
// 表示块内元素总和
void add(int l, int r, long long x) {  // 区间加法
  int sid = id[l], eid = id[r];
  if (sid == eid) {  // 在一个块中
    for (int i = l; i <= r; i++) a[i] += x, s[sid] += x;
    return;
  }
  for (int i = l; id[i] == sid; i++) a[i] += x, s[sid] += x;
  for (int i = sid + 1; i < eid; i++) b[i] += x, s[i] += len * x;  // 更新区间和数组(完整的块)
  for (int i = r; id[i] == eid; i--) a[i] += x, s[eid] += x;
  // 以上两行不完整的块直接简单求和,就OK
}
long long query(int l, int r, long long p) {  // 区间查询
  int sid = id[l], eid = id[r];
  long long ans = 0;
  if (sid == eid) {  // 在一个块里直接暴力求和
    for (int i = l; i <= r; i++) ans = (ans + a[i] + b[sid]) % p;
    return ans;
  }
  for (int i = l; id[i] == sid; i++) ans = (ans + a[i] + b[sid]) % p;
  for (int i = sid + 1; i < eid; i++) ans = (ans + s[i]) % p;
  for (int i = r; id[i] == eid; i--) ans = (ans + a[i] + b[eid]) % p;
  // 和上面的区间修改是一个道理
  return ans;
}
int main() {
  int n;
  cin >> n;
  len = sqrt(n);  // 均值不等式可知复杂度最优为根号n
  for (int i = 1; i <= n; i++) {  // 题面要求
    cin >> a[i];
    id[i] = (i - 1) / len + 1;//各个id对应哪个区块
    s[id[i]] += a[i];
  }
  for (int i = 1; i <= n; i++) {
    int op, l, r, c;
    cin >> op >> l >> r >> c;
    if (op == 0)
      add(l, r, c);
    else
      cout << query(l, r, c + 1) << endl;
  }
  system("pause");
  return 0;
}
```

### 块状数组

#### Problem 1

#### 描述

1.区间[x,y]每个数上都加上z

2.查询区间[x,y]内大于等于z的数的个数

#### 代码

```c++
//st[],ed[]每个区块在n上的开始位置与结束位置
//belong[]在n上的每个数属于哪个区块
//size[],区块i的长度
ll a[N],st[N],ed[N],belong[N],leng[N],t[N],delta[N];
void Sort(int k){//给区块
	for(int i=st[k];i<=ed[k];i++)	t[i]=a[i];
	sort(t+st[k],t+ed[k]+1);
}
void Modify(int l, int r, int c) {
  int x = belong[l], y = belong[r];
  if (x == y)  // 区间在一个块内就直接修改
  {
    for (int i = l; i <= r; i++) a[i] += c;
    Sort(x);
    return;
  }
  for (int i = l; i <= ed[x]; i++) a[i] += c;     // 直接修改起始段
  for (int i = st[y]; i <= r; i++) a[i] += c;     // 直接修改结束段
  for (int i = x + 1; i < y; i++) delta[i] += c;  // 中间的块整体打上标记
  Sort(x);Sort(y);
}

int Answer(int l, int r, int c) {
  int ans = 0, x = belong[l], y = belong[r];
  if (x == y) {
    for (int i = l; i <= r; i++)
      if (a[i] + delta[x] >= c) ans++;
    return ans;
  }
  for (int i = l; i <= ed[x]; i++)
    if (a[i] + delta[x] >= c) ans++;
  for (int i = st[y]; i <= r; i++)
    if (a[i] + delta[y] >= c) ans++;
  for (int i = x + 1; i <= y - 1; i++)
    ans +=ed[i] - (lower_bound(t + st[i], t + ed[i] + 1, c - delta[i]) - t) + 1;        
  // 用 lower_bound 找出中间每一个整块中第一个大于等于 c 的数的位置
  return ans;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	int n,m;
	cin>>n>>m;
	int num=sqrt(n);
  for(int i=1;i<=n;i++){
    cin>>a[i];
    belong[i]=min((i-1)/num+1,num);
  }
  for(int i=1;i<=num;i++){
    st[i]=n/num*(i-1)+1,ed[i]=n/num*i;
    if(i==num)  ed[i]=n;//如果num*num<=n的情况，将最后多的值放到最后一个组中。
    leng[i]=ed[i]-st[i]+1;
    Sort(i);
  }
  for(int i=1;i<=m;i++){
		char x;
		int q,w,e;
		cin>>x>>q>>w>>e;
		if(x=='A')      cout<<Answer(q,w,e)<<endl;
		else Modify(q,w,e);
	}
	system("pause");
}
```

#### Problem 2

#### 描述

1.区间[x,y]每个数都变成z

2.查询区间[x,y]内小于等于z的数的个数

#### 区间操作思路

用`delta` 数组记录现在块内的赋值是什么，如果未被整体赋值，用一个特殊值(`0x3f3f3f3f3f3f3f3fll`)加以表示，考虑边角情况时，查询前使用`pushdown`,把块内存的信息下放到每一个数上,赋值完`Sort`。

```c++
void Sort(int k) {
  for (int i = st[k]; i <= ed[k]; i++) t[i] = a[i];
  sort(t + st[k], t + ed[k] + 1);
}

void PushDown(int x) {
  if (delta[x] != 0x3f3f3f3f3f3f3f3fll)  // 用该值标记块内没有被整体赋值
    for (int i = st[x]; i <= ed[x]; i++) a[i] = t[i] = delta[x];
  delta[x] = 0x3f3f3f3f3f3f3f3fll;
}

void Modify(int l, int r, int c) {
  int x = belong[l], y = belong[r];
  PushDown(x);
  if (x == y) {
    for (int i = l; i <= r; i++) a[i] = c;
    Sort(x);
    return;
  }
  PushDown(y);
  for (int i = l; i <= ed[x]; i++) a[i] = c;
  for (int i = st[y]; i <= r; i++) a[i] = c;
  Sort(x);
  Sort(y);
  for (int i = x + 1; i < y; i++) delta[i] = c;
}

int Binary_Search(int l, int r, int c) {
  int ans = l - 1, mid;
  while (l <= r) {
    mid = (l + r) / 2;
    if (t[mid] <= c)
      ans = mid, l = mid + 1;
    else
      r = mid - 1;
  }
  return ans;
}

int Answer(int l, int r, int c) {
  int ans = 0, x = belong[l], y = belong[r];
  PushDown(x);
  if (x == y) {
    for (int i = l; i <= r; i++)
      if (a[i] <= c) ans++;
    return ans;
  }
  PushDown(y);
  for (int i = l; i <= ed[x]; i++)
    if (a[i] <= c) ans++;
  for (int i = st[y]; i <= r; i++)
    if (a[i] <= c) ans++;
  for (int i = x + 1; i <= y - 1; i++) {
    if (0x3f3f3f3f3f3f3f3fll == delta[i])
      ans += Binary_Search(st[i], ed[i], c) - st[i] + 1;
    else if (delta[i] <= c)
      ans += size[i];
  }
  return ans;
}
```

### 树状数组

![屏幕截图 2022-11-25 162058](C:\Users\HP\Desktop\Algorithm\算法\images\屏幕截图 2022-11-25 162058.png)

### 用法及操作

#### Problem 1

如何知道c[i]管理数组a的哪个区间呢？

`lowbit`

```c++
//快速找到二级制表示中，最低位的1的位置
int lowbit(int x){return x&-x;}
```

`增减操作`

```c++
void add(int x,int k){ while(x<=n)	c[x]+=k,x+=lowbit(x);}
```

`前缀求和`

```c++
int getsum(int x){//a[1]~a[x]的sum和
    int ans=0;
    while(x>=1)	ans+=c[x],x-=lowbit(x);
    return ans;
}
```

### 高精度四则运算代码

```c++
#include <cstdio>
#include <cstring>
static const int LEN = 1004;
int a[LEN], b[LEN], c[LEN], d[LEN];
void clear(int a[]) {
  for (int i = 0; i < LEN; ++i) a[i] = 0;
}
void read(int a[]) {
  static char s[LEN + 1];
  scanf("%s", s);
  clear(a);
  int len = strlen(s);
  for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
}

void print(int a[]) {
  int i;
  for (i = LEN - 1; i >= 1; --i)
    if (a[i] != 0) break;
  for (; i >= 0; --i) putchar(a[i] + '0');
  putchar('\n');
}

void add(int a[], int b[], int c[]) {
  clear(c);
  for (int i = 0; i < LEN - 1; ++i) {
    c[i] += a[i] + b[i];
    if (c[i] >= 10) {
      c[i + 1] += 1;c[i] -= 10;
    }
  }
}

void sub(int a[], int b[], int c[]) {
  clear(c);
  for (int i = 0; i < LEN - 1; ++i) {
    c[i] += a[i] - b[i];
    if (c[i] < 0) {
      c[i + 1] -= 1;c[i] += 10;
    }
  }
}

void mul(int a[], int b[], int c[]) {
  clear(c);
  for (int i = 0; i < LEN - 1; ++i) {
    for (int j = 0; j <= i; ++j) c[i] += a[j] * b[i - j];
    if (c[i] >= 10) {
      c[i + 1] += c[i] / 10; c[i] %= 10;
    }
  }
}

inline bool greater_eq(int a[], int b[], int last_dg, int len) {
  if (a[last_dg + len] != 0) return true;
  for (int i = len - 1; i >= 0; --i) {
    if (a[last_dg + i] > b[i]) return true;
    if (a[last_dg + i] < b[i]) return false;
  }
  return true;
}

void div(int a[], int b[], int c[], int d[]) {
  clear(c);
  clear(d);
  int la, lb;
  for (la = LEN - 1; la > 0; --la)
    if (a[la - 1] != 0) break;
  for (lb = LEN - 1; lb > 0; --lb)
    if (b[lb - 1] != 0) break;
  if (lb == 0) {puts("> <");return;
  }
  for (int i = 0; i < la; ++i) d[i] = a[i];
  for (int i = la - lb; i >= 0; --i) {
    while (greater_eq(d, b, i, lb)) {
      for (int j = 0; j < lb; ++j) {
        d[i + j] -= b[j];
        if (d[i + j] < 0) {
          d[i + j + 1] -= 1;
          d[i + j] += 10;
        }
      }
      c[i] += 1;
    }
  }
}
int main() {
  read(a);	char op[4];	scanf("%s", op);	read(b);
  switch (op[0]) {
    case '+':	add(a, b, c);	print(c);break;
    case '-':	sub(a, b, c);	print(c);break;
    case '*':	mul(a, b, c);	print(c);break;
    case '/':	div(a, b, c, d);print(c);print(d);break;
    default:
      puts("> <");
  }
  return 0;
}
```

### 快速幂

```c++
/*x^n mod m*/
// C++ Version
ll binpow(ll a, ll b, ll m) {
  a %= m;
  long long res = 1;
  while (b > 0) {
    if (b & 1) res = res * a % m;
    a = a * a % m;
    b >>= 1;
  }
  return res;
}
```

### 快速幂逆元

```c++
ll qpInverse(ll n,ll p){//n在modp下的逆元 
	return qp(n,p-2,p);}
```

### 欧几里得

```c++
int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
```

### 最小公倍数LCM

#### 定义

一组整数的公倍数，是指同时是这组数中每一个数的倍数的数。0 是任意一组整数的公倍数。

一组整数的最小公倍数，是指所有正的公倍数里面，最小的一个数。

#### 结论

gcd(a,b)* lcm(a,b)=a*b

### 拓展欧几里得算法 EXGCD

![屏幕截图 2022-11-15 231728](C:\Users\HP\Desktop\Algorithm\算法\数学\数论\images\屏幕截图 2022-11-15 231728.png)

```c++
// C++ Version 递归求法
int Exgcd(int a, int b, int &x, int &y) {
  if (!b) {x = 1;y = 0;return a;}
  int d = Exgcd(b, a % b, x, y);
  int t = x;x = y;  y = t - (a / b) * y;
  return d;
}
```

### 判断一个素数

```c++
inline bool is_prime(int x){
    if(x<2)	return false;
    for(register int i=2;i*i<=x;++i)
        if(x%i==0)	return false;
    return true;
}
```

#### 埃氏筛

```c++
int v[N];
void primes(int n{
    memset(v, 0, sizeof v);
    for(int i = 2;i <= n; ++ i){
        if(v[i])continue;
        cout << i << endl;
        for(int j = i;j <= n / i; ++ j)
            v[i * j] = 1;
    }
}

```

#### 线性筛(欧拉筛)

复杂度O(n)

```c++
int n, primes[N], cnt;
bool vis[N];
inline void get_prime()
{
	for(register int i = 2;i <= n;i ++) {
    	if(!vis[i]) primes[ ++ cnt] = i;
    	for(register int j = 1;j <= cnt && i * primes[j] <= n; ++ j) {
        	vis[i * primes[j]] = 1;
            if(i % primes[j] == 0) break;
    	}
    }
}	

```

### KMP

```c++
int kmp[MAXN];
int la,lb,j;
char a[MAXN],b[MAXN];
int KmpSearch(char*a, char*b)
{
	int la = strlen(a+1);
	int lb = strlen(b+1);
	j=0;
	int flag=0;
	for(int i=1;i<=la;i++){
		while(j>0&&b[j+1]!=a[i])	j=kmp[j];
		if(b[j+1]==a[i])	j++;
		if(j==lb)	{
			flag=1;
			cout<<i-lb+1<<endl;
			j=kmp[j];
		}
	}
	return flag;	
}

void Getkmp(char*b, int kmp[])
{
	int j=0;
	lb=strlen(b+1);
	for(int i=2;i<=lb;i++){
		while(j&&b[i]!=b[j+1])	j=kmp[j];
		if(b[j+1]==b[i])	j++;
		kmp[i]=j;
	}
}
int main(){
	cin>>a+1;
	cin>>b+1;
	Getkmp(b,kmp);
	int t=KmpSearch(a,b);
}
```

### Read

```c++
inline int read()
{
    int k=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
    while(ch>='0'&&ch<='9')
	{
		k=k*10+ch-'0';
		ch=getchar();
	}
    return k*f;
}
template<class type_name> inline type_name qr(type_name sample)
{
    type_name ret=0,sgn=1;
    char cur=getchar();
    while(!isdigit(cur))
        sgn=(cur=='-'?-1:1),cur=getchar();
    while(isdigit(cur))
        ret=(ret<<1)+(ret<<3)+cur-'0',cur=getchar();
    return sgn==-1?-ret:ret;
}
/*使用案例  int a=qr(1);
			ll b=qr(1ll);
```

### 容斥

题意：问你有多少种方案构造一个长度为n的序列b，对于1<=i<=n，满足b[i]<=m且gcd(b[1],b[2],....b[i])=a[i]。答案对998224353取模

题解：第一位的数是固定的，后面的数必须满足a[i-1]%a[i]==0。后面运用容斥原理求(1到m/a[i]中)与a[i-1]/a[i]互质数的个数，采用容斥板子

```c++
int T,n,m,lst,a;
int main() {
	cin>>T;
	while(T--) {
		cin>>n>>m>>lst;
		int ans=1;
		for(int i=1; i<n; i++) {
			cin>>a;
			if(lst%a)ans=0;
			if(ans==0)continue;
			int nw=lst/a;
			vector<int>pr;//存储nw的所有因子，重复的合并
			for(int j=2; j<=sqrt(nw); j++)
				if(nw%j==0) {
					pr.push_back(j);
					while(nw%j==0)nw/=j;
				}
			if(nw!=1)pr.push_back(nw);
			int t=0;
			for(int j=0; j<(1<<pr.size()); j++) {
				int mul=1,tp=1;//mul记录互质数的数量
				for(int k=0; k<pr.size(); k++){
					if(j&(1<<k))	mul*=pr[k],tp=-tp;
				}
				t=((t+m/mul/a*tp)%mod+mod)%mod;
			}
			ans=1ll*ans*t%mod;
			lst=a;
		}
		cout<<ans<<'\n';
	}
}
```

```c++
#include<bits/stdc++.h>
using namespace std;
#define Fopen freopen("_in.txt","r",stdin); freopen("_out.txt","w",stdout);
#define ll long long
#define Ull unsigned ll
#define lll __int128
#define RP(i,a,b) for(register int i=a;i<=b;++i)
#define DRP(i,a,b) for(register int i=a;i>=b;--i)
#define INF 2147483647
typedef unsigned long long ull;
typedef double db;
typedef pair<ll,ll>PII;
const int inf = 0x7f7f7f7f;
const int MAXN=1e5+7;
const int mod=1e9+7;
const int MOD=998244353;
const int N=1e6+7;
/*2^32==42949672962  2^31-1==2147483647
int main(){ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);}
__int128 用快读*/
//m.insert({int,int});
int main() {
    //ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);
	//ios_base::sync_with_stdio(false);	cin.tie(0); cout.tie(0);
	int _=1;
	cin>>_;
	while(_--) solve();
}



```

