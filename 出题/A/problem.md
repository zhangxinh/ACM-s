## 最有序的字符串

###### 时间限制：2000ms 空间限制：1024M

##### 题目描述：

为了减少熵增的进度，上帝打算处理世间的一切值，使世界变的井然有序。

世界的一切可以看作是有一系列数据组成的，相当于一条条字符串，现在有一条字符串$T$仅由小写字母构成，一个字符串的混乱程度可以用$f(T)$来表示。

> $f(T)$:对字符串$T$进行不限次的以下操作：每次都将最前面的字符放到最后一位。求在这个过程中产生的不同的字符串的数量有多少。

作为上帝自然有无限的力量能够将字符串$T$中的字符变成全部相同的字符使得$f(T)$为$1$,但是你只是一个凡人你只有$k$次力量能将其中的字符改变，现在需要你在有限的$k$次机会中使修改后的$f(T')$最小。
##### 输入格式：

第一行包含两个整数 $N (1 \leq N \leq 2000)$，$K  (0 \leq K \leq N)$ ，$n$表示输入字符串的长度，$k$表示你能将字符串中任意小写字母修改为任意小写字母的次数。

第二行包含一个字符串 $S $,字符串的长度就是$N$，该字符串仅由小写字母构成。

##### 输出格式：

设修改后的字符串为$T'$，输出$f(T')$的值。
##### 样例输入1：

```
4 1
abac
```

##### 样例输出1：

```
2
```

##### 样例输入2：

```
6 1
abcaba
```

##### 样例输出2：

```
3
```


##### 样例输入3：

```
6 6
abcaba
```

##### 样例输出3：

```
1
```
##### 样例解释：
对于样例$1$，其中一种方法是将`abac`修改成`abab`，这样得出的$f(T')$就是$2$。

对于样例$2$，其中一种方法是将`abcaba`修改成`abaaba`，这样得出的$f(T')$就是$3$。

对于样例$3$，其中一种方法是将`abcaba`修改成`aaaaaa`，这样得出的$f(T')$就是$1$。

