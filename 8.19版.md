#### CMakeLists

```c++
add_definitions(-D LOCAL)
```

```c++
#include<bits/stdc++.h>
#include<numeric>
using namespace std;
template<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (y<x) { x=y; return 1; } return 0; }
template<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }
#define ll long long
#define pb emplace_back
#define fs first
#define sc second
#define mpi make_pair
#define re(a) {cout<<a<<endl;return;}
#define all(v) v.begin(),v.end()
//#define all(v, n) v.begin()+1,v.begin()+n+1
#define fr(i, a, n)  for(int i = a; i <= n; i++)
const int N = 2e5 + 7;
const int M = 1e18 + 7;
const ll inf = 1e10;
const int mod = 998244353;
//function<void(int,int)>dfs=[&](int x,int y)->void{};
//sort(last.begin(),last.begin()+n,[&](pair<ll,ll>x,pair<ll,ll>y){
//if(x.first==y.first)    return x.second<y.second;
//return x.first>y.first;
//});
void solve(){
    int n;	cin >> n;
}
signed main(){
#ifdef  LOCAL
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    ios::sync_with_stdio(0);    cin.tie(0);
    int _ = 1;
    cin >> _;//处理多组样例T
    while (_--) solve();
}

```

#### 快读

```c++
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
```

#### int128

```c++
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int rd() {
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
	return x*f;
}

inline void write(__int128_t x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
```



#### 阶乘预处理

`阶乘以及其逆元预处理`

```c++
ll fac[N + 3], invfac[N + 3];
long long binpow(long long a, long long b) {
    a %= mod;
    long long res = 1;
    while (b > 0) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
ll C(ll n, ll m){
    ll ans = (fac[n] * invfac[m] % mod) * invfac[n - m] % mod;
    return ans;
}
fac[0] = 1;
for(int i = 1; i < N; i++)	fac[i] =(fac[i - 1] * i) % mod;
invfac[N - 1] = binpow(fac[N - 1], mod - 2);
for(int i = N - 2; i >= 0; i--)	invfac[i] = invfac[i + 1] * (i + 1) % mod;
```

#### 逆元预处理

`1-n分母逆元预处理`

```c++
ll inv[N + 2];
inv[1] = 1;
for(ll i = 2; i <= n; i++){
    inv[i] = (m - m / i) * inv[m % i] % m;
}
```

### 打表

#### 全排列打表

`一个数组，要求输出它从小到大的全排列`

```c++
vc<int>a(n);
fr(i, 0, n - 1)	cin >> a[i];
sort(all(a));
fr(i, 0, n - 1)	cout << a[i] <<" ";
cout << "\n";
do{fr(i, 0, n)	cout << a[i] <<" ";
   cout <<"\n";
}while(next_permutation(all(a)));
```

####  排列组合

`从一个集合里取出它所有的非空子集`

```c++
fr(i, 0, (1 << n) - 1){
    fr(j, 0, n - 1)
        if(i & (1 << j))	cout << a[j] <<" ";
    cout <<"\n";
}
```

`从一个集合里取出它所有大小为k的子集`

```c++
int num, kk;
fr(i, 0, (1 << n) - 1){
    num = 0,kk = i;
    while(kk){
        kk = kk & (kk - 1);
        num ++;
    }
    if(num == k){
        fr(j, 0, n - 1)
        	if(i & (1 << j))	cout << a[j] <<" ";
    	cout <<"\n";
    }
}
```

### 数据结构

#### ST表

```c++
const int N = 1e5 + 10, M = 20;
int st[N][M];
int n, m;

int query(int l, int r)
{
	int x = log2(r - l + 1);
	return max(st[l][x], st[r - (1 << x) + 1][x]);
}

void solve()
{
	cin >> n >> m;
	fer(i, 1, n)cin >> st[i][0];
	fer(j, 1, 18)
	{
		for (int i = 1; i + (1 << j) - 1 <= n; i++)
		{
			st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
		}
	}
	while (m--)
	{
		int l, r;
		cin >> l >> r;
		cout << query(l, r) << endl;
	}
}
```

#### 并查集

```c++
struct DSU {
    std::vector<int> f, siz;
     
    DSU() {}
    DSU(int n) {
        init(n);
    }
     
    void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
     
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
     
    bool same(int x, int y) {
        return find(x) == find(y);
    }
     
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
     
    int size(int x) {
        return siz[find(x)];
    }
};
```

#### 树状数组

```c++
const int N = 1e5 + 7;
ll Btree[N];
int lowbit(int x){
    return x & -x;
}
ll getsum(int x){
    int ans = 0;
    while(x > 0){
        ans += Btree[x];
        x -= lowbit(x);
    }
    return ans;
}
void add(int x, ll k){
    while(x <= n){
        Btree[x] += k;
        x += lowbit(x);
    }
}
//O(n)建树
void init() {
	for (int i = 1; i <= n; ++i) {
		Btree[i] += a[i];
		int j = i + lowbit(i);
		if (j <= n) Btree[j] += Btree[i];
	}
}
```

#### 单调栈

```c++
ll n;   cin>>n;
vector<ll>h(n+2);
for(int i=1;i<=n;i++)   cin>>h[i];
h[n+1]=0;
stack<ll>s;
ll maxans=0;
for(int i=1;i<=n+1;i++){
	while(!s.empty()){
		if(h[i]>=h[s.top()])    break;
		ll id=s.top();  s.pop();
		ll area=h[id]*(s.empty()?i-1:i-s.top()-1);
		maxans=max(maxans,area);
	}
	s.push(i);
}
cout<<maxans<<"\n";
```

#### 单调队列

```c++
int q[maxn], a[maxn];
int n, k;
void getmin() {
    ∕∕ 得到这个队列里的最小值，直接找到最后的就行了
    int head = 0, tail = 0;
    for (int i = 1; i < k; i++) {
        while (head <= tail && a[q[tail]] >= a[i]) tail--;
        q[++tail] = i;
    }
    for (int i = k; i <= n; i++) {
        while (head <= tail && a[q[tail]] >= a[i]) tail--;
        q[++tail] = i;
        while (q[head] <= i - k) head++;
        printf("%d ", a[q[head]]);
    }
}

void getmax() {
    ∕∕ 和上面同理
    int head = 0, tail = 0;
    for (int i = 1; i < k; i++) {
        while (head <= tail && a[q[tail]] <= a[i]) tail--;
        q[++tail] = i;
    }
    for (int i = k; i <= n; i++) {
        while (head <= tail && a[q[tail]] <= a[i]) tail--;
        q[++tail] = i;
        while (q[head] <= i - k) head++;
        printf("%d ", a[q[head]]);
    }
}
```

