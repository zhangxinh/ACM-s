#### CMakeLists(in Clion)

```c++
add_definitions(-D LOCAL)
```

```c++
#include<bits/stdc++.h>
#include<numeric>
using namespace std;
template<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (y<x) { x=y; return 1; } return 0; }
template<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }
#define ll long long
#define pb emplace_back
#define fs first
#define sc second
#define mpi make_pair
#define re(a) {cout<<a<<endl;return;}
#define all(v) v.begin(),v.end()
//#define all(v, n) v.begin()+1,v.begin()+n+1
#define fr(i, a, n)  for(int i = a; i <= n; i++)
const int N = 2e5 + 7;
const int M = 1e18 + 7;
const ll inf = 1e10;
const int mod = 998244353;
//function<void(int,int)>dfs=[&](int x,int y)->void{};
//sort(last.begin(),last.begin()+n,[&](pair<ll,ll>x,pair<ll,ll>y){
//if(x.first==y.first)    return x.second<y.second;
//return x.first>y.first;
//});
void solve(){
    int n;	cin >> n;
}
signed main(){
#ifdef  LOCAL
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    ios::sync_with_stdio(0);    cin.tie(0);
    int _ = 1;
    cin >> _;//处理多组样例T
    while (_--) solve();
}

```

#### 快读

```c++
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
```

#### int128

```c++
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int rd() {
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
	return x*f;
}

inline void write(__int128_t x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
```

### 预处理

#### 阶乘预处理

`阶乘以及其逆元预处理`

```c++
ll fac[N + 3], invfac[N + 3];
long long binpow(long long a, long long b) {
    a %= mod;
    long long res = 1;
    while (b > 0) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
ll C(ll n, ll m){
    ll ans = (fac[n] * invfac[m] % mod) * invfac[n - m] % mod;
    return ans;
}
fac[0] = 1;
for(int i = 1; i < N; i++)	fac[i] =(fac[i - 1] * i) % mod;
invfac[N - 1] = binpow(fac[N - 1], mod - 2);
for(int i = N - 2; i >= 0; i--)	invfac[i] = invfac[i + 1] * (i + 1) % mod;
```

#### 逆元预处理

`1-n分母逆元预处理`

```c++
ll inv[N + 2];
inv[1] = 1;
for(ll i = 2; i <= n; i++){
    inv[i] = (m - m / i) * inv[m % i] % m;
}
```

### 打表

#### 全排列打表

`一个数组，要求输出它从小到大的全排列`

```c++
vc<int>a(n);
fr(i, 0, n - 1)	cin >> a[i];
sort(all(a));
fr(i, 0, n - 1)	cout << a[i] <<" ";
cout << "\n";
do{fr(i, 0, n)	cout << a[i] <<" ";
   cout <<"\n";
}while(next_permutation(all(a)));
```

####  排列组合

`从一个集合里取出它所有的非空子集`

```c++
fr(i, 0, (1 << n) - 1){
    fr(j, 0, n - 1)
        if(i & (1 << j))	cout << a[j] <<" ";
    cout <<"\n";
}
```

`从一个集合里取出它所有大小为k的子集`

```c++
int num, kk;
fr(i, 0, (1 << n) - 1){
    num = 0,kk = i;
    while(kk){
        kk = kk & (kk - 1);
        num ++;
    }
    if(num == k){
        fr(j, 0, n - 1)
        	if(i & (1 << j))	cout << a[j] <<" ";
    	cout <<"\n";
    }
}
```

### 数据结构

#### ST表

```c++
const int N = 1e5 + 10, M = 20;
int st[N][M];
int n, m;

int query(int l, int r)
{
	int x = log2(r - l + 1);
	return max(st[l][x], st[r - (1 << x) + 1][x]);
}

void solve()
{
	cin >> n >> m;
	fer(i, 1, n)cin >> st[i][0];
	fer(j, 1, 18)
	{
		for (int i = 1; i + (1 << j) - 1 <= n; i++)
		{
			st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
		}
	}
	while (m--)
	{
		int l, r;
		cin >> l >> r;
		cout << query(l, r) << endl;
	}
}
```

#### 并查集

```c++
struct DSU {
    std::vector<int> f, siz;
     
    DSU() {}
    DSU(int n) {
        init(n);
    }
     
    void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
     
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
     
    bool same(int x, int y) {
        return find(x) == find(y);
    }
     
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
     
    int size(int x) {
        return siz[find(x)];
    }
};
```

#### 树状数组

```c++
const int N = 1e5 + 7;
ll Btree[N];
int lowbit(int x){
    return x & -x;
}
ll getsum(int x){
    int ans = 0;
    while(x > 0){
        ans += Btree[x];
        x -= lowbit(x);
    }
    return ans;
}
void add(int x, ll k){
    while(x <= n){
        Btree[x] += k;
        x += lowbit(x);
    }
}
//O(n)建树
void init() {
	for (int i = 1; i <= n; ++i) {
		Btree[i] += a[i];
		int j = i + lowbit(i);
		if (j <= n) Btree[j] += Btree[i];
	}
}
```

#### 单调栈

```c++
ll n;   cin>>n;
vector<ll>h(n+2);
for(int i=1;i<=n;i++)   cin>>h[i];
h[n+1]=0;
stack<ll>s;
ll maxans=0;
for(int i=1;i<=n+1;i++){
	while(!s.empty()){
		if(h[i]>=h[s.top()])    break;
		ll id=s.top();  s.pop();
		ll area=h[id]*(s.empty()?i-1:i-s.top()-1);
		maxans=max(maxans,area);
	}
	s.push(i);
}
cout<<maxans<<"\n";
```

#### 单调队列

```c++
int q[maxn], a[maxn];
int n, k;
void getmin() {
    ∕∕ 得到这个队列里的最小值，直接找到最后的就行了
    int head = 0, tail = 0;
    for (int i = 1; i < k; i++) {
        while (head <= tail && a[q[tail]] >= a[i]) tail--;
        q[++tail] = i;
    }
    for (int i = k; i <= n; i++) {
        while (head <= tail && a[q[tail]] >= a[i]) tail--;
        q[++tail] = i;
        while (q[head] <= i - k) head++;
        printf("%d ", a[q[head]]);
    }
}

void getmax() {
    ∕∕ 和上面同理
    int head = 0, tail = 0;
    for (int i = 1; i < k; i++) {
        while (head <= tail && a[q[tail]] <= a[i]) tail--;
        q[++tail] = i;
    }
    for (int i = k; i <= n; i++) {
        while (head <= tail && a[q[tail]] <= a[i]) tail--;
        q[++tail] = i;
        while (q[head] <= i - k) head++;
        printf("%d ", a[q[head]]);
    }
}
```

#### 线段树

1、区间加，区间SUM

```c++
LL n, a[100005], d[270000], b[270000];

void build(LL l, LL r, LL p) {  // l:区间左端点 r:区间右端点 p:节点标号
  if (l == r) {
    d[p] = a[l];  // 将节点赋值
    return;
  }
  LL m = l + ((r - l) >> 1);
  build(l, m, p << 1), build(m + 1, r, (p << 1) | 1);  // 分别建立子树
  d[p] = d[p << 1] + d[(p << 1) | 1];
}

void update(LL l, LL r, LL c, LL s, LL t, LL p) {
  if (l <= s && t <= r) {
    d[p] += (t - s + 1) * c, b[p] += c;  // 如果区间被包含了，直接得出答案
    return;
  }
  LL m = s + ((t - s) >> 1);
  if (b[p])
    d[p << 1] += b[p] * (m - s + 1), d[(p << 1) | 1] += b[p] * (t - m),
        b[p << 1] += b[p], b[(p << 1) | 1] += b[p];
  b[p] = 0;
  if (l <= m)
    update(l, r, c, s, m, p << 1);  // 本行和下面的一行用来更新p*2和p*2+1的节点
  if (r > m) update(l, r, c, m + 1, t, (p << 1) | 1);
  d[p] = d[p << 1] + d[(p << 1) | 1];  // 计算该节点区间和
}

LL getsum(LL l, LL r, LL s, LL t, LL p) {
  if (l <= s && t <= r) return d[p];
  LL m = s + ((t - s) >> 1);
  if (b[p])
    d[p << 1] += b[p] * (m - s + 1), d[(p << 1) | 1] += b[p] * (t - m),
        b[p << 1] += b[p], b[(p << 1) | 1] += b[p];
  b[p] = 0;
  LL sum = 0;
  if (l <= m)
    sum =
        getsum(l, r, s, m, p << 1);  // 本行和下面的一行用来更新p*2和p*2+1的答案
  if (r > m) sum += getsum(l, r, m + 1, t, (p << 1) | 1);
  return sum;
}

int main() {
  std::ios::sync_with_stdio(0);
  LL q, i1, i2, i3, i4;
  std::cin >> n >> q;
  for (LL i = 1; i <= n; i++) std::cin >> a[i];
  build(1, n, 1);
  while (q--) {
    std::cin >> i1 >> i2 >> i3;
    if (i1 == 2)
      std::cout << getsum(i2, i3, 1, n, 1) << std::endl;  // 直接调用操作函数
    else
      std::cin >> i4, update(i2, i3, i4, 1, n, 1);
  }
  return 0;
}
```

2、区间加乘区间SUM

```c++
#define ll long long
ll read() {
    ll w = 1, q = 0;
    char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') w = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') q = (ll) q * 10 + ch - '0', ch = getchar();
    return (ll) w * q;
}

int n, m;
ll mod;
ll a[100005], sum[400005], mul[400005], laz[400005];

void up(int i) { sum[i] = (sum[(i << 1)] + sum[(i << 1) | 1]) % mod; }

void pd(int i, int s, int t) {
    int l = (i << 1), r = (i << 1) | 1, mid = (s + t) >> 1;
    if (mul[i] != 1) {  // 懒标记传递，两个懒标记
        mul[l] *= mul[i];   mul[l] %= mod;  mul[r] *= mul[i];   mul[r] %= mod;
        laz[l] *= mul[i];   laz[l] %= mod;  laz[r] *= mul[i];   laz[r] %= mod;
        sum[l] *= mul[i];   sum[l] %= mod;  sum[r] *= mul[i];   sum[r] %= mod;
        mul[i] = 1;
    }
    if (laz[i]) {  // 懒标记传递
        sum[l] += laz[i] * (mid - s + 1);   sum[l] %= mod;
        sum[r] += laz[i] * (t - mid);   sum[r] %= mod;
        laz[l] += laz[i];   laz[l] %= mod;  laz[r] += laz[i];   laz[r] %= mod;
        laz[i] = 0;
    }
    return;
}

void build(int s, int t, int i) {
    mul[i] = 1;
    if (s == t) {
        sum[i] = a[s];
        return;
    }
    int mid = s + ((t - s) >> 1);
    build(s, mid, i << 1);  // 建树
    build(mid + 1, t, (i << 1) | 1);
    up(i);
}

void chen(int l, int r, int s, int t, int i, ll z) {
    int mid = s + ((t - s) >> 1);
    if (l <= s && t <= r) {
        mul[i] *= z;    mul[i] %= mod;
        laz[i] *= z;    laz[i] %= mod;
        sum[i] *= z;    sum[i] %= mod;
        return;
    }
    pd(i, s, t);
    if (mid >= l) chen(l, r, s, mid, (i << 1), z);
    if (mid + 1 <= r) chen(l, r, mid + 1, t, (i << 1) | 1, z);
    up(i);
}

void add(int l, int r, int s, int t, int i, ll z) {
    int mid = s + ((t - s) >> 1);
    if (l <= s && t <= r) {
        sum[i] += z * (t - s + 1);  sum[i] %= mod;
        laz[i] += z;    laz[i] %= mod;
        return;
    }
    pd(i, s, t);
    if (mid >= l) add(l, r, s, mid, (i << 1), z);
    if (mid + 1 <= r) add(l, r, mid + 1, t, (i << 1) | 1, z);
    up(i);
}

ll getans(int l, int r, int s, int t,
          int i) {  // 得到答案，可以看下上面懒标记助于理解
    int mid = s + ((t - s) >> 1);
    ll tot = 0;
    if (l <= s && t <= r) return sum[i];
    pd(i, s, t);
    if (mid >= l) tot += getans(l, r, s, mid, (i << 1));
    tot %= mod;
    if (mid + 1 <= r) tot += getans(l, r, mid + 1, t, (i << 1) | 1);
    return tot % mod;
}

int main() {  // 读入
    int i, j, x, y, bh;
    ll z;
    cin >> n >> m;
    mod = read();
    for (i = 1; i <= n; i++) a[i] = read();
    build(1, n, 1);  // 建树
    for (i = 1; i <= m; i++) {
        bh = read();
        if (bh == 1) {
            cin >> x >> y >> z;
            chen(x, y, 1, n, 1, z);
        } else if (bh == 2) {
            cin >> x >> y >> z;
            add(x, y, 1, n, 1, z);
        } else if (bh == 3) {
            cin >> x >> y;
            printf("%lld\n", getans(x, y, 1, n, 1));
        }
    }
    return 0;
}
```

3、区间修改成一个定值

```c++
int n, a[100005], d[270000], b[270000];

void build(int l, int r, int p) {  // 建树
  if (l == r) {
    d[p] = a[l];
    return;
  }
  int m = l + ((r - l) >> 1);
  build(l, m, p << 1), build(m + 1, r, (p << 1) | 1);
  d[p] = d[p << 1] + d[(p << 1) | 1];
}

void update(int l, int r, int c, int s, int t,
            int p) {  // 更新，可以参考前面两个例题
  if (l <= s && t <= r) {
    d[p] = (t - s + 1) * c, b[p] = c;
    return;
  }
  int m = s + ((t - s) >> 1);
  if (b[p]) {
    d[p << 1] = b[p] * (m - s + 1), d[(p << 1) | 1] = b[p] * (t - m);
    b[p << 1] = b[(p << 1) | 1] = b[p];
    b[p] = 0;
  }
  if (l <= m) update(l, r, c, s, m, p << 1);
  if (r > m) update(l, r, c, m + 1, t, (p << 1) | 1);
  d[p] = d[p << 1] + d[(p << 1) | 1];
}

int getsum(int l, int r, int s, int t, int p) {  // 取得答案，和前面一样
  if (l <= s && t <= r) return d[p];
  int m = s + ((t - s) >> 1);
  if (b[p]) {
    d[p << 1] = b[p] * (m - s + 1), d[(p << 1) | 1] = b[p] * (t - m);
    b[p << 1] = b[(p << 1) | 1] = b[p];
    b[p] = 0;
  }
  int sum = 0;
  if (l <= m) sum = getsum(l, r, s, m, p << 1);
  if (r > m) sum += getsum(l, r, m + 1, t, (p << 1) | 1);
  return sum;
}

int main() {
  std::ios::sync_with_stdio(0);
  std::cin >> n;
  for (int i = 1; i <= n; i++) std::cin >> a[i];
  build(1, n, 1);
  int q, i1, i2, i3, i4;
  std::cin >> q;
  while (q--) {
    std::cin >> i1 >> i2 >> i3;
    if (i1 == 0)
      std::cout << getsum(i2, i3, 1, n, 1) << std::endl;
    else
      std::cin >> i4, update(i2, i3, i4, 1, n, 1);
  }
  return 0;
}
```

### 数论

#### GCD

```c++
// Version 1
int gcd(int a, int b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}

// Version 2
int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
```

#### 快速幂

##### 一般快速幂

```c++
long long binpow(long long a, long long b, long long m) {
  a %= m;
  long long res = 1;
  while (b > 0) {
    if (b & 1) res = res * a % m;
    a = a * a % m;
    b >>= 1;
  }
  return res;
}
```

##### 矩阵快速幂

### 图论以及树上问题

#### LCA

##### 倍增

```c++
/*
input
5 5 4	//5个点，5次LCA询问，4为树的根节点。
3 1
2 4
5 1
1 4
2 4
3 2
3 5
1 2
4 5
*/

vc<int> depth(N + 2),edge[N + 2];
vc<vc<int>>fa(N + 2,vc(22 , 0));
void solve() {
    int n, q ,root;  cin >> n >> q >> root;
    int u, v;
    fr(i, 2, n){
        cin >> u >> v;
        edge[u].pb(v);
        edge[v].pb(u);
    }
    vector<int>lg(n);
    fr(i, 1, n) lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);
    function<void(int, int)>dfs = [&](int now,int fath)->void{
        fa[now][0] = fath;//第一个父亲节点是自己
        depth[now] = depth[fath] + 1;
        fr(i, 1, lg[depth[now]])    fa[now][i] = fa[fa[now][i - 1]][i - 1];
        for(auto i:edge[now])   if(i != fath) dfs(i, now);
    };
    function<int(int, int)>lca = [&](int x,int y)->int{
        if(depth[x] < depth[y]) swap(x, y);
        while(depth[x] > depth[y])  x = fa[x][lg[depth[x] - depth[y]] - 1];
        if(x == y)  return x;
        for(int k = lg[depth[x]] - 1;k >= 0; k--)
            if(fa[x][k] != fa[y][k])    x = fa[x][k], y = fa[y][k];
        return fa[x][0];
    };
    dfs(root, 0);
    rep(q){
        cin >> u >> v;
        cout << lca(u, v) <<"\n";
    }
}
```

##### 树剖写法

1.判断两点是否在同一条链上，是则能直接得到答案

2.否则，令深度较大的点变成它重链端的父节点，得到新的两点，重复以上步骤。

树剖步骤

定义siz[x] 为以x为根结点的子树节点个数

对x的每个子节点，找到其最大的节点y，使得siz[y] >= siz[z]。

```c++
vc<int>dep(N + 2),edge[N + 2],fa(N + 2),son(N + 2),siz(N + 2), top(N + 2);
//son存最大的儿子子树
void solve() {
    int n, q ,root;  cin >> n >> q >> root;
    int u, v;
    fr(i, 2, n){
        cin >> u >> v;
        edge[u].pb(v);
        edge[v].pb(u);
    }
    function<void(int)>dfs1 = [&](int x)->void{
        siz[x] = 1;
        dep[x] = dep[fa[x]] + 1;
        for(auto i : edge[x]){
            if(i == fa[x]) continue;
            fa[i] = x;
            dfs1(i);
            siz[x] += siz[i];
            if(!son[x] || siz[son[x]] < siz[i]) son[x] = i;
        }
    };
    function<void(int, int)>dfs2 = [&](int x, int tv)->void{
        top[x] = tv;
        if(son[x])  dfs2(son[x], tv);
        for(auto i:edge[x]){
            if(i == fa[x] || i == son[x]) continue;
            dfs2(i,i);
        }
    };
    dfs1(root);
    dfs2(root, root);
    int ans;
    rep(q){
        cin >> u >> v;
        while(top[u] != top[v])
            dep[top[u]] >= dep[top[v]] ? u = fa[top[u]] : v = fa[top[v]];
        ans = (dep[u] < dep[v] )? u : v;
        cout<<ans <<"\n";
    }
}
```

#### 树的直径

##### DFS

选定一个点，进行dfs，找到最深的点，在最深的点dfs，最大路径便是直径

```c++
void solve() {
    int n;  cin >> n;
    vc<pair<int,int>>edge[n + 2];//pair<v,w> u->v,value = w;
    vc<int>pre(n + 2);
    fr(i, 2, n){
         int v, w;   cin >> v >>w;
         edge[i].pb(mpi(v,w));
         edge[v].pb(mpi(i,w));
    }
    int mx = 1;
    function<void(int, int)>dfs=[&](int x,int fa){
        for(auto [v, w]: edge[x]){
            if(v == fa) continue;
            pre[v] = pre[x] + w;
            if(pre[v] > pre[mx])    mx = v;
            dfs(v,x);
        }
    };
    dfs(1, 0);
    fill(all(pre),0);
    dfs(mx, 0);
    cout << pre[mx] << "\n";
}
```

##### 树形DP求

在任意节点跑树形DP维护这些节点最大的两条链的值，D = max(D, d[i].first + d[i].second)。

```c++
void solve() {
    int n;  cin >> n;
    vc<pair<int, int>> d(n + 2);//pair<max_edge,nextmax_edge>;
    vc<pair<int, int>> edge[n + 2];//pair<v,w> u->v,value = w;
    fr(i, 2, n){
        int v, w;   cin >> v >>w;
        edge[i].pb(mpi(v,w));
        edge[v].pb(mpi(i,w));
    }
    int mx = 1;
    function<void(int,int)>dfs=[&](int x,int fa){
        d[x].first = d[x].second = 0;
        for(auto [v,w]: edge[x]){
            if(v == fa) continue;
            dfs(v, x);
            int now = d[v].first + w;
            if(now > d[x].first) d[x].second = d[x].first, d[x].first = now;
            else if(now > d[x].second)  d[x].second = now;
        }
        if(d[x].first + d[x].second > d[mx].first + d[mx].second)    mx = x;
    };
    dfs(1, 0);
    cout << mx <<"\n";
    cout << d[mx].first + d[mx].second <<"\n";
}
```

